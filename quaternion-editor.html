<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<title>四元数编辑器（草方块 / 三环选轴 / 轨道视角 / 角度可编辑）</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://unpkg.com/three@0.159.0/build/three.min.js" crossorigin="anonymous"></script>
<style>
  html, body { height:100%; margin:0; background:#0f1115; color:#e6e6e6;
    font-family:ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
  #app { height:100%; display:grid; grid-template-rows:1fr auto; }
  #canvas { width:100%; height:100%; display:block; touch-action:none; }
  #panel { display:flex; flex-wrap:wrap; gap:.75rem; align-items:center; padding:.75rem 1rem;
    background:#171a21; border-top:1px solid #2a2f3a; }
  .mono { font-family:ui-monospace, Menlo, Consolas, "Liberation Mono", monospace; }
  #quat { padding:.5rem .75rem; background:#0b0d12; border:1px solid #283142; border-radius:.5rem; }
  button { cursor:pointer; border:1px solid #3a4252; background:#222734; color:#e6e6e6;
    padding:.45rem .8rem; border-radius:.5rem; font-weight:600; }
  button:hover { background:#2a3040; }
  .badge { opacity:.9; font-size:.85rem; padding:.25rem .5rem; border:1px solid #3a4252; border-radius:.4rem; }
  .angles { display:flex; gap:.5rem; align-items:center; }
  .angles label { display:flex; gap:.25rem; align-items:center; }
  .angles input { width:4.6rem; padding:.35rem .4rem; border:1px solid #3a4252; border-radius:.35rem;
    background:#0b0d12; color:#e6e6e6; }
</style>
</head>
<body>
<div id="app">
  <canvas id="canvas"></canvas>
  <div id="panel">
    <div class="angles">
      <label>X° <input id="angX" type="number" step="1" value="0"></label>
      <label>Y° <input id="angY" type="number" step="1" value="0"></label>
      <label>Z° <input id="angZ" type="number" step="1" value="0"></label>
      <button id="applyEuler">应用XYZ</button>
    </div>
    <div id="quat" class="mono">[0, 0, 0, 1]</div>
    <button id="copyBtn">复制</button>
    <button id="zoomOut">缩小</button>
    <button id="zoomIn">放大</button>
    <button id="resetBtn">重置</button>
    <div id="modeBadge" class="badge">空闲</div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const quatDiv = document.getElementById('quat');
  const copyBtn = document.getElementById('copyBtn');
  const resetBtn = document.getElementById('resetBtn');
  const modeBadge = document.getElementById('modeBadge');
  const angX = document.getElementById('angX');
  const angY = document.getElementById('angY');
  const angZ = document.getElementById('angZ');
  const applyEulerBtn = document.getElementById('applyEuler');
  const zoomInBtn = document.getElementById('zoomIn');
  const zoomOutBtn = document.getElementById('zoomOut');

  // ===== 基础 =====
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0f1115);

  const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 100);
  camera.position.set(3, 2.2, 4);
  camera.up.set(0,1,0);
  camera.lookAt(0, 0, 0);

  const ambient = new THREE.AmbientLight(0xffffff, 0.75);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 1.0);
  dir.position.set(2, 4, 1);
  scene.add(dir);

  function onResize() {
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, rect.width | 0);
    const h = Math.max(1, rect.height | 0);
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  onResize(); window.addEventListener('resize', onResize); setTimeout(onResize, 0);

  // ===== 纹理（来自你给的三张图：底/侧 + 绿色化顶面；已Base64内嵌）=====
  const TEX = {
    dirt: [
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/",
"9hAAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQ",
"AAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASA",
"AAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAEKADAAQAAAABAAAAEAAAAADHbx",
"zxAAADM0lEQVR4nCXHzU4iBwDA8f8MAzqYGHHFQRs4GWMF1God6EpiPHqyrd34DG",
"026aW39t7sC/QVvLR9CE0kBhQmGC8yfOrA8L2rODjATA/93X7C33/+4jYaDQRBoF",
"wuI8tzxGIx2u02juNgGAYzMzPous7a2hqvry+oqko+n0dVVcTr62sEQSCXy+H3+3",
"Fdl36/z/z8PJqmIUkS8XicRCLBZDIhlUrR6XSo1+ucn58j/Pvpo5vL5Xh9fWUwGH",
"By8gOXl5cA+P1+tre3KRQKvLy8IAgCT091RFHk7OyMdDqN9PT0hM/nY39/n4uLC6",
"rVKu12m0gkwubmJtVqlYWFBabTKYFAgNlZH3t7e5RKJURRRHRdl8lkQqlUIpVKkc",
"1mSSaTWJaFpml4vV7S6TQAjuMwHA7RdR1N0xiNRgi/ney63W6XnZ0dxuMxX768sL",
"i4SD6fx3VdBEEgEolg2zbdbpfl5SVs22Zubo5oNIrwz6ef3UKhgPX6hizLrK+vo2",
"kaguBBVVUkSeLq6oqdnS1kWSaTyaAoCk3TIBgMIvx+lnAnkwm733yLLMvouo4kST",
"SbLRzHIRQKkc1mef8+yXA4pNPp4PF4eLcUwOfzISlLQUzT5P7ujkAgwOfBAL/fj+",
"hCu9WGqUNyX+XNsvjc7+OTJGzb5r5wh6IoSIPBgFAoxO1tHoDJZIKu64wsm3A4jN",
"frpVar4ZuRAEgkEliWRT5/y+rqKqJlWXg8HhQlSDT6NaqqoigKP334kcV3C1RrZZ",
"LfqaiqyuPjI6VSkU6nxcbGBqVSCeGvX793K5UKfr+f5eVlQGRlZYWbmxuCwSCj0Q",
"hZlhEEgVarRbmsk0qlMAwD0zQR/viguqZpsrW1hWmarKx8xXg8JhwOc39/j+M4vL",
"294fV6mU6nwP8/OjpiOBwiTqdTdnd3qdfreDweKpUKw+GQRqNBIBBgPB5jGAaxWA",
"zDMHAch8PDQx4eHuj1eoiRSIRms0m/3ycejzM7O0uxWMQwDDKZDKqqcnp6Sj6f5+",
"DgAMdxSKfTeL1enp+fkWzbxrZtjo+PMU2TUCgEQDQaRRRFdF3H5/MhiiLFYpFIJA",
"JArVaj1+vxH0RgmI7HKApAAAAAAElFTkSuQmCC"
    ].join(''),
    side: [
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/",
"9hAAAAhGVYSWZNTQAqAAAACAAFARIAAwAAAAEAAQAAARoABQAAAAEAAABKARsABQ",
"AAAAEAAABSASgAAwAAAAEAAgAAh2kABAAAAAEAAABaAAAAAAAAAEgAAAABAAAASA",
"AAAAEAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAEKADAAQAAAABAAAAEAAAAADHbx",
"zxAAADVklEQVR4nCXPWW4bBQCA4X/GM7bj0Mb7EtdxG7ehSbMoSx0DoQ28QKUUlZ",
"AiBNwBLtAn7sAhEGpEi5CqIigUgUIVq+QhgsRbnWTscbwv2J4Zz/DAd4NPeLD7sS",
"UKAqZuMNINhv0BTtcY1XqN8YmLXPBPMLIs2t0O3XaHcYcTvT+g02gQj00h2nUbem",
"tI5GIQhyHhc3l48vAHfC4v8kjkPF/G5/IwHYpzJRzH6hr4XF5C4z4kTUCcdPj4df",
"cpUYcfoTrE2QG37sRruvj5myck3FM42xa2hkFY8vDXj3sMTpt4zQs8+/YpwtZW0E",
"pMT5M5OkYWbdzd2uLh7i6Sw87Q0FnfSPHTL8/49PPPePzdIwJeH0rxBJfdSdDvR/",
"jqy/etdruNz+0hHAzx/aPH3Nq8zT/HR9jsMiclBbvTQaPZZHVlhU6rSTQUZn/vT6",
"5OJ5C65Q61coXA6x7+Pe8xE72G3tTQagM0s4fdkLl25SqaT6NwkCMaCdFWWszGrj",
"OXmEVcmp0nfmmKbqNN9u9jkstrVEsVPK9NsH33Hp98uEO33mJ+Zpade9vIyET8EQ",
"RDoH7eQDo6PGKo9UneTCFLIplMjstTcU7PSvz2/DmT0RjN8xpVtUrLVkcWZPK5HI",
"l4AkEAye13o6oD0gdpfG43zXYLzRjDFE0ajTqCKLKyuoyuGZTOq4iIyLJE+iBNKB",
"REajZrhMNB0uk0MIVhGJzlThkMBsRiMWRZplgs4JCdCJisp1L0+z1evjxgcjKMOO",
"z3kG0CkVCAhRuzJNfXCIUD7Nzfxutz86qY541UklRyDeW0SCGXoV6tMHd9hkIug/",
"D1Fx9YhUIBl8tFMBjEFCASibC/v08gEEDra4yNjSEIApVKhXw+z8bGBoqioKoqwo",
"OdNUtVVRaWFlFVldBkFF3XiV+KcXh4iDUyGQ6HyLLMaDQCRIbDIZvvvkOv10McjS",
"yWV1c4OTlDkGQKhQK9Xo9SqYTH40HXRyhKmcUbiyhKGdM0ubV5m+OjLNV6HTEWv0",
"y5XKHRaLEwv4TT4eI4k+NUKfPixT7Jmyk+2r5P+uUBb735NuYI/vh9D5vdTrvbQ9",
"I0DU0zeO/Onf8LkTCWAPNzC4iiRDabxW63I4o2MpkssXgcU4BisUitXuc/QmKFeT",
"m3xXUAAAAASUVORK5CYII="
    ].join(''),
    top: [
"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAIAAACQkW",
"g2AAACRElEQVR4nCXPSXLbOBQA0A/gA58EKJJWWUo65XSqsulL5EA5WC7mRcqOB8",
"kUScxDFv1u8NjPXz/m++HysqaQGWOqQ3sLqpeKsNaaYoEGwEAP9Pa0DhPx1uDt6a",
"YIVScloV3C4ahzKnYL/aCok6jE+WH2LulB1dJQEboUbu+OI1MdChLRJ5QCAFIopD",
"Gn+vx4zbG01j5/m/HtaTUHhYqrDmtp1KFbI2kZQ96WwjmjXqoOGYNh7t+fN37/5Z",
"BCuTsbvyU9KDMSkjAjnR/m5DNjTCBXHdbc7BoYA0wh64meH5fjp+Hj1ZKWKIXb08",
"e7He76HItdQ3S5MxJak4TobdIDnb4c9i0qjd5GSZhTAYAcy3wyJVUrA2kZfW61IU",
"rhbQSmWm3AWautM2pfHPWqN/LyZ2utSSVabX6L08lgP6j/rygFIo8uScn7gXqjSi",
"o1VzIy+swF1xMtrzvmVOwS9Nd5ebeMMz0SAKwX57YoldAjCeQMmBlp+/AcOW8VzN",
"zdrnY89slnPdC2+OGuOz9MfovU4Xp1tdbbxTHGpBLcb7E3KvqUYtEjXf5sAOBtur",
"5seurWD88FO8x9dDn4lGLh53/n9eoYY3YNtTRFWGurqdbaSi4AkENxezx+MiVV6p",
"G//l5IS7cnlMLvEQCiy/98P1IvOeeHuR/vjZDidnXTyZiRuBmp1fbtv1Ow6fR1Nh",
"PpA11ftvXiGId99fvNMwAzdX4Lz48L328hxfL6e0El3BbsGoFBa60zcrofgs13J7",
"PdvF1DazCfzF+R/mmjUz0jCAAAAABJRU5ErkJggg=="
    ].join('')
  };

  function makeNearestTexture(url) {
    const tex = new THREE.TextureLoader().load(url);
    tex.colorSpace = THREE.SRGBColorSpace;
    tex.magFilter = THREE.NearestFilter;
    tex.minFilter = THREE.NearestFilter;
    tex.generateMipmaps = false;
    tex.anisotropy = 1;
    return tex;
  }

  const texTop  = makeNearestTexture(TEX.top);
  const texSide = makeNearestTexture(TEX.side);
  const texBottom = makeNearestTexture(TEX.dirt);

  // ===== 层级：world(轴) + content(环) + model(方块) =====
  const worldGroup = new THREE.Group();     // 坐标轴/箭头（不缩放或仅放大时变长）
  scene.add(worldGroup);
  const contentGroup = new THREE.Group();   // 三色环（不缩放，通过改半径“放大不变粗”）
  worldGroup.add(contentGroup);
  const modelGroup = new THREE.Group();     // 方块（真正缩放）
  worldGroup.add(modelGroup);

  // 坐标轴 + 箭头（>1 变长，头部粗细不变；<=1 保持初始）
  const AXIS_LEN_BASE = 2.4;
  let axesHelper = new THREE.AxesHelper(AXIS_LEN_BASE);
  worldGroup.add(axesHelper);
  const HEAD_LEN = AXIS_LEN_BASE * 0.16;
  const HEAD_WIDTH = AXIS_LEN_BASE * 0.07;
  const arrowX = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), AXIS_LEN_BASE, 0xff4444, HEAD_LEN, HEAD_WIDTH);
  const arrowY = new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), AXIS_LEN_BASE, 0x44ff44, HEAD_LEN, HEAD_WIDTH);
  const arrowZ = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), AXIS_LEN_BASE, 0x4488ff, HEAD_LEN, HEAD_WIDTH);
  worldGroup.add(arrowX, arrowY, arrowZ);

  function setAxesLength(len) {
    worldGroup.remove(axesHelper);
    axesHelper.geometry.dispose();
    axesHelper = new THREE.AxesHelper(len);
    worldGroup.add(axesHelper);
    arrowX.setLength(len, HEAD_LEN, HEAD_WIDTH);
    arrowY.setLength(len, HEAD_LEN, HEAD_WIDTH);
    arrowZ.setLength(len, HEAD_LEN, HEAD_WIDTH);
  }

  // ===== 方块（六面贴图：+Y=草顶、-Y=泥土、其它=草侧）=====
  const boxGeo = new THREE.BoxGeometry(1, 1, 1);
  const matSide  = new THREE.MeshStandardMaterial({ map: texSide, metalness: 0, roughness: 1 });
  const matTop   = new THREE.MeshStandardMaterial({ map: texTop,  metalness: 0, roughness: 1 });
  const matBottom= new THREE.MeshStandardMaterial({ map: texBottom, metalness: 0, roughness: 1 });
  const faceMaterials = [matSide, matSide, matTop, matBottom, matSide, matSide]; // +x -x +y -y +z -z
  const cube = new THREE.Mesh(boxGeo, faceMaterials);
  modelGroup.add(cube);

  // ===== 三色环（可见环半径随放大增加；粗细保持固定；缩小时保持初始）=====
  const RING_R_BASE = 0.86, RING_TUBE_VIS = 0.030, RING_TUBE_PICK = 0.095;
  function makeRing(axisName, colorHex) {
    const g = new THREE.Group();

    const torus = new THREE.Mesh(
      new THREE.TorusGeometry(RING_R_BASE, RING_TUBE_VIS, 16, 160),
      new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.95, depthTest: true })
    );
    g.add(torus);

    // 拾取专用隐形加粗环
    const pick = new THREE.Mesh(
      new THREE.TorusGeometry(RING_R_BASE, RING_TUBE_PICK, 8, 80),
      new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.0, depthTest: false })
    );
    g.add(pick);

    const head = new THREE.Mesh(
      new THREE.ConeGeometry(0.065, 0.18, 20),
      new THREE.MeshBasicMaterial({ color: colorHex, transparent: true, opacity: 0.95 })
    );
    g.add(head);

    // 环平面法线（局部 Z）对齐到目标轴
    const axisVec = axisName === 'x' ? new THREE.Vector3(1,0,0)
                   : axisName === 'y' ? new THREE.Vector3(0,1,0)
                   :                     new THREE.Vector3(0,0,1);
    g.quaternion.setFromUnitVectors(new THREE.Vector3(0,0,1), axisVec);

    function placeArrow(radius) {
      const phi = 0.0;
      const p = new THREE.Vector3(radius*Math.cos(phi), radius*Math.sin(phi), 0);
      const t = new THREE.Vector3(-Math.sin(phi), Math.cos(phi), 0).normalize();
      head.position.copy(p.clone().add(t.clone().multiplyScalar(0.10)));
      head.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), t);
    }
    placeArrow(RING_R_BASE);

    g.userData = { axisName, torus, pick, head, placeArrow };
    contentGroup.add(g);
    return g;
  }
  const ringX = makeRing('x', 0xff4444);
  const ringY = makeRing('y', 0x44ff44);
  const ringZ = makeRing('z', 0x4488ff);
  const ringGroups = { x: ringX, y: ringY, z: ringZ };

  function setRingRadius(radius) {
    for (const R of [ringX, ringY, ringZ]) {
      R.userData.torus.geometry.dispose();
      R.userData.torus.geometry = new THREE.TorusGeometry(radius, RING_TUBE_VIS, 16, 160);
      R.userData.pick.geometry.dispose();
      R.userData.pick.geometry = new THREE.TorusGeometry(radius, RING_TUBE_PICK, 8, 80);
      R.userData.placeArrow(radius);
    }
  }

  // ===== 工具 =====
  const raycaster = new THREE.Raycaster();
  const ndc = new THREE.Vector2();
  function setNDCFromEvent(e) {
    const rect = canvas.getBoundingClientRect();
    ndc.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    ndc.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  }
  function formatNum(n){ if (Math.abs(n) < 1e-8) n = 0; return n.toFixed(6); }
  function updateQuatText(){ const q=cube.quaternion;
    quatDiv.textContent = `[${formatNum(q.x)}, ${formatNum(q.y)}, ${formatNum(q.z)}, ${formatNum(q.w)}]`;
  }
  function updateAngleInputsFromQuat(){
    const e = new THREE.Euler().setFromQuaternion(cube.quaternion, 'XYZ');
    const d = (r)=>THREE.MathUtils.radToDeg(r);
    function normDeg(x){ x=((x+180)%360+360)%360-180; return Math.abs(x)<1e-4?0:x; }
    angX.value = normDeg(d(e.x)).toFixed(1);
    angY.value = normDeg(d(e.y)).toFixed(1);
    angZ.value = normDeg(d(e.z)).toFixed(1);
  }
  updateQuatText(); updateAngleInputsFromQuat();

  // 角度连续解包 + 45°吸附
  function unwrapAdd(acc, prevRaw, raw){ let d=raw-prevRaw; while(d> Math.PI) d-=2*Math.PI; while(d<-Math.PI) d+=2*Math.PI; return {acc:acc+d, raw}; }
  const SNAP_STEP = Math.PI/4, SNAP_TOL = THREE.MathUtils.degToRad(4);
  function snapAngle(a){ const k=Math.round(a/SNAP_STEP), t=k*SNAP_STEP; return Math.abs(a-t)<=SNAP_TOL? t : a; }

  // ===== 状态 =====
  const State = { Idle:0, DragRing:1, DragOrbit:2 };
  let state = State.Idle;

  // —— 拖环（单轴旋转）
  const startPointer = new THREE.Vector2(), currPointer = new THREE.Vector2();
  let activeAxis = null;                 // 'x'|'y'|'z'
  const plane = new THREE.Plane();       // 法向=axisWorld（世界轴）
  const centerWorld = new THREE.Vector3(0,0,0);
  const vStart = new THREE.Vector3(), vCurr = new THREE.Vector3();
  let startQuatCube = new THREE.Quaternion();
  let prevRawAngle = 0, accAngle = 0, haveRaw = false;

  // —— 轨道视角（球坐标：稳定无翻转；左右=Yaw；上下=Pitch【已反向修正】）——
  const orbitStart = new THREE.Vector2();
  let orbitMode = null; // 'yaw'|'pitch'
  const ORBIT_SENS = 0.010;
  let r0 = 5, yaw0 = 0, pitch0 = 0;   // 起始球坐标
  let yaw = 0, pitch = 0;
  const PITCH_MIN = THREE.MathUtils.degToRad(-88);
  const PITCH_MAX = THREE.MathUtils.degToRad(+88);
  const target = new THREE.Vector3(0,0,0);

  function computeSphericalFromCamera(){
    const off = camera.position.clone().sub(target);
    r0 = off.length();
    yaw0 = Math.atan2(off.x, off.z);                   // 绕 Y
    pitch0 = Math.atan2(off.y, Math.sqrt(off.x*off.x + off.z*off.z)); // [-pi/2, pi/2]
  }
  function applyCameraFromYawPitch(){
    const cp = Math.cos(pitch), sp = Math.sin(pitch);
    const sy = Math.sin(yaw),    cy = Math.cos(yaw);
    const off = new THREE.Vector3(r0*cp*sy, r0*sp, r0*cp*cy);
    camera.position.copy(target.clone().add(off));
    camera.up.set(0,1,0);
    camera.lookAt(target);
  }

  // ===== 事件 =====
  function onPointerDown(e){
    e.preventDefault();
    try{ canvas.setPointerCapture?.(e.pointerId); }catch{}
    camera.updateMatrixWorld();

    const rect = canvas.getBoundingClientRect();
    startPointer.set(e.clientX - rect.left, e.clientY - rect.top);
    currPointer.copy(startPointer);

    // 优先命中三色环（用隐形加粗环）
    setNDCFromEvent(e);
    raycaster.setFromCamera(ndc, camera);
    const hits = raycaster.intersectObjects([ringX.userData.pick, ringY.userData.pick, ringZ.userData.pick], false);

    if (hits.length){
      // ---- 拖环：单轴旋转（世界轴 X/Y/Z）----
      state = State.DragRing;
      const mesh = hits[0].object;
      const g = [ringX,ringY,ringZ].find(R => R.userData.pick === mesh);
      activeAxis = g.userData.axisName;
      modeBadge.textContent = `单轴旋转（${activeAxis.toUpperCase()}）`;
      Object.values(ringGroups).forEach(R => {
        const on = (R === g);
        R.userData.torus.material.opacity = on ? 1.0 : 0.35;
        R.userData.head .material.opacity = on ? 1.0 : 0.35;
      });

      startQuatCube.copy(cube.quaternion);
      prevRawAngle = 0; accAngle = 0; haveRaw = false;

      const axisWorld = activeAxis==='x' ? new THREE.Vector3(1,0,0)
                        : activeAxis==='y' ? new THREE.Vector3(0,1,0)
                        :                      new THREE.Vector3(0,0,1);
      plane.setFromNormalAndCoplanarPoint(axisWorld, centerWorld);

      const p0 = new THREE.Vector3();
      if (raycaster.ray.intersectPlane(plane, p0)){
        vStart.copy(p0.clone().sub(centerWorld));
        vStart.sub(axisWorld.clone().multiplyScalar(vStart.dot(axisWorld))).normalize();
      }

    }else{
      // ---- 轨道视角：球坐标 ----
      state = State.DragOrbit;
      modeBadge.textContent = '视角（轨道）';
      orbitMode = null;
      computeSphericalFromCamera();
    }
  }

  function onPointerMove(e){
    const rect = canvas.getBoundingClientRect();
    currPointer.set(e.clientX - rect.left, e.clientY - rect.top);

    if (state === State.DragRing && activeAxis){
      setNDCFromEvent(e);
      raycaster.setFromCamera(ndc, camera);
      const p = new THREE.Vector3();
      if (!raycaster.ray.intersectPlane(plane, p)) return;

      const axisWorld = activeAxis==='x' ? new THREE.Vector3(1,0,0)
                        : activeAxis==='y' ? new THREE.Vector3(0,1,0)
                        :                      new THREE.Vector3(0,0,1);

      vCurr.copy(p.clone().sub(centerWorld));
      vCurr.sub(axisWorld.clone().multiplyScalar(vCurr.dot(axisWorld))).normalize();
      const cross = new THREE.Vector3().crossVectors(vStart, vCurr);
      const sinSigned = cross.dot(axisWorld);
      const cos = THREE.MathUtils.clamp(vStart.dot(vCurr), -1, 1);
      const raw = Math.atan2(sinSigned, cos);

      if (!haveRaw){ prevRawAngle=raw; accAngle=0; haveRaw=true; }
      const u = unwrapAdd(accAngle, prevRawAngle, raw);
      accAngle = u.acc; prevRawAngle = u.raw;

      const useAngle = snapAngle(accAngle);
      const axisLocal = axisWorld.clone();
      const qDelta = new THREE.Quaternion().setFromAxisAngle(axisLocal, useAngle);
      cube.quaternion.copy(qDelta.multiply(startQuatCube));
      updateQuatText(); updateAngleInputsFromQuat();

    } else if (state === State.DragOrbit){
      const dx = currPointer.x - startPointer.x;
      const dy = currPointer.y - startPointer.y;

      if (!orbitMode){
        if (Math.hypot(dx, dy) < 6) return; // 死区
        orbitMode = (Math.abs(dx) >= Math.abs(dy)) ? 'yaw' : 'pitch';
        modeBadge.textContent = (orbitMode==='yaw') ? '视角：水平 (Yaw)' : '视角：垂直 (Pitch)';
      }

      // 水平：左右 = yaw0 - dx * sens（已校正方向）
      // 垂直：上下 = pitch0 + dy * sens（已反转：上划抬头）
      let newYaw   = yaw0   - (orbitMode==='yaw'   ? dx*ORBIT_SENS : 0);
      let newPitch = pitch0 + (orbitMode==='pitch' ? dy*ORBIT_SENS : 0);
      newPitch = THREE.MathUtils.clamp(newPitch, PITCH_MIN, PITCH_MAX);

      yaw = newYaw; pitch = newPitch;
      applyCameraFromYawPitch();
    }
  }

  function onPointerUp(e){
    try{ canvas.releasePointerCapture?.(e.pointerId); }catch{}
    state = State.Idle; activeAxis = null; modeBadge.textContent = '空闲';
    Object.values(ringGroups).forEach(R => {
      R.userData.torus.material.opacity = 0.95;
      R.userData.head .material.opacity = 0.95;
    });
  }

  canvas.addEventListener('pointerdown', onPointerDown, { passive:false });
  window.addEventListener('pointermove', onPointerMove, { passive:false });
  window.addEventListener('pointerup',   onPointerUp);
  canvas.addEventListener('contextmenu', e => e.preventDefault());

  // ===== 面板：复制 / 缩放 / 重置 / 角度应用 =====
  copyBtn.addEventListener('click', async () => {
    const text = quatDiv.textContent;
    try { await navigator.clipboard.writeText(text);
      copyBtn.textContent = '已复制 ✓'; setTimeout(()=>copyBtn.textContent='复制', 1200);
    } catch { alert('已显示四元数，若复制失败请手动选中复制：\n' + text); }
  });

  let sizeFactor = 1.0; // “内容尺寸系数”：>1 放大；<1 缩小
  function applySize(){
    // 1) 方块：始终按 sizeFactor 缩放
    modelGroup.scale.setScalar(sizeFactor);

    // 2) 三色环：>1 时半径随之增大（tube 粗细不变）；<=1 保持初始
    const ringR = sizeFactor > 1 ? RING_R_BASE * sizeFactor : RING_R_BASE;
    setRingRadius(ringR);

    // 3) 坐标轴：>1 时变长（箭头头部宽高不变）；<=1 保持初始
    const axisLen = sizeFactor > 1 ? AXIS_LEN_BASE * sizeFactor : AXIS_LEN_BASE;
    setAxesLength(axisLen);
  }
  zoomInBtn.addEventListener('click', ()=>{ sizeFactor = Math.min(2.5, sizeFactor*1.12); applySize(); });
  zoomOutBtn.addEventListener('click', ()=>{ sizeFactor = Math.max(0.6, sizeFactor/1.12); applySize(); });

  resetBtn.addEventListener('click', () => {
    cube.quaternion.set(0,0,0,1);
    updateQuatText(); updateAngleInputsFromQuat();
    // 相机复位
    camera.position.set(3, 2.2, 4);
    camera.up.set(0,1,0); camera.lookAt(0,0,0);
    // 尺寸复位
    sizeFactor = 1.0; applySize();
    modeBadge.textContent = '空闲';
  });

  applyEulerBtn.addEventListener('click', () => {
    const d2r = THREE.MathUtils.degToRad;
    const ex = d2r(parseFloat(angX.value || 0));
    const ey = d2r(parseFloat(angY.value || 0));
    const ez = d2r(parseFloat(angZ.value || 0));
    const e = new THREE.Euler(ex, ey, ez, 'XYZ');
    cube.quaternion.setFromEuler(e);
    updateQuatText(); updateAngleInputsFromQuat();
  });

  // ===== 渲染 =====
  function tick(){ renderer.render(scene, camera); requestAnimationFrame(tick); }
  tick();
})();
</script>
</body>
</html>