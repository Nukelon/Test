<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>æ‹¼å›¾å°æ¸¸æˆ Â· è‡ªå®šä¹‰åˆ†å‰²æ•° Â· è§¦å±ä¼˜åŒ–</title>
<style>
  :root{
    --cell: 96px;            /* å•å—å°ºå¯¸ï¼ˆJS ä¼šæŒ‰å±å¹•&ç½‘æ ¼è‡ªé€‚é…ï¼‰ */
    --gap-board: 4px;        /* æ£‹ç›˜æ ¼é—´è·ï¼ˆå·²æŒ‰ä½ ä¹‹å‰è¦æ±‚è°ƒå°ï¼‰ */
    --gap-tray: 6px;         /* æ‰˜ç›˜æ‹¼å—é—´è· */
    --radius: 8px;
  }
  *{box-sizing:border-box}
  html,body{overscroll-behavior:contain}
  body{margin:0; padding:16px; font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","PingFang SC","Microsoft YaHei"; background:#f6f7fb; color:#222}
  h1{font-size:18px; margin:0 0 12px}
  .top{display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom:10px}
  input[type=file]{padding:8px; background:#fff; border:1px solid #e3e6ef; border-radius:8px}
  select,button,input[type=number]{appearance:none; border:1px solid #d7dbec; background:#fff; padding:8px 12px; border-radius:8px; cursor:pointer}
  input[type=number]{width:86px}
  button:disabled{opacity:.5; cursor:not-allowed}
  .game{display:grid; grid-template-columns: auto minmax(220px,1fr); gap:16px; align-items:start}
  .board{
    display:grid; gap:var(--gap-board); padding:var(--gap-board); border-radius:var(--radius);
    background:#e9ecf5; position:relative;
    box-shadow:0 1px 0 rgba(0,0,0,.02), 0 6px 24px rgba(0,0,0,.06) inset;
    touch-action:none;
  }
  .board::before{
    content:""; position:absolute; left:var(--gap-board); right:var(--gap-board);
    top:var(--gap-board); bottom:var(--gap-board); border-radius:10px;
    background-image: var(--ref-url, none); background-size:100% 100%; background-position:center;
    opacity: var(--ref-opacity, 0); transition: opacity .18s ease; pointer-events:none;
  }
  .cell{width:var(--cell); height:var(--cell); border-radius:6px; background:#fff; outline:2px dashed #e0e4f2; outline-offset:-6px; position:relative}
  .tray-wrap{display:flex; flex-direction:column; gap:8px}
  .tray-title{margin:6px 0 0; font-size:14px; color:#555; display:flex; align-items:center; gap:10px; flex-wrap:wrap}
  .tray{display:flex; flex-wrap:wrap; gap:var(--gap-tray); background:#fff; padding:10px; min-height: calc(var(--cell)*2 + var(--gap-tray));
    border-radius:var(--radius); box-shadow:0 6px 24px rgba(0,0,0,.06); touch-action:none}
  .piece{
    width:var(--cell); height:var(--cell); border-radius:6px; user-select:none; -webkit-user-drag:none;
    background-position:center; background-size:cover; background-repeat:no-repeat;
    border:1px solid #e1e5f1; box-shadow:0 1px 2px rgba(0,0,0,.06); touch-action:none;
  }
  .piece.dragging{
    opacity:.95; box-shadow:0 10px 24px rgba(0,0,0,.18); border-color:#c9d0ea;
    pointer-events:none; position:fixed; z-index:9999; transform:scale(1.05);
  }
  .drop-hint{outline-color:#b8c4ff !important; background:#f6f8ff}
  .panel{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .status{font-size:14px; color:#666}
  .status a{color:#1a73e8; text-decoration:none}
  .status a:hover{text-decoration:underline}
  .win{
    position:absolute; left:var(--gap-board); right:var(--gap-board); top:var(--gap-board); bottom:var(--gap-board);
    border-radius:10px; background:rgba(255,255,255,.85);
    display:none; align-items:center; justify-content:center; font-size:28px; font-weight:700; color:#1aa85b;
    backdrop-filter: blur(2px);
  }
  .board.win-show .win{display:flex}
  .note{font-size:13px; color:#888; margin-top:6px}
  .overlay{position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.72); padding:16px}
  .overlay.show{display:flex}
  .overlay img{max-width:92vw; max-height:92vh; border-radius:10px; box-shadow:0 10px 30px rgba(0,0,0,.6)}
  @media (max-width:820px){ .game{grid-template-columns:1fr} }
</style>
</head>
<body>
  <h1>æ‹¼å›¾å°æ¸¸æˆï¼ˆä¸Šä¼ å›¾ç‰‡ â†’ è‡ªåŠ¨è£åˆ‡ â†’ æ‹–åŠ¨æ‘†æ”¾ï¼‰</h1>

  <div class="top">
    <input id="file" type="file" accept="image/*" />

    <!-- å¿«é€‰ï¼ˆæ–¹é˜µï¼‰ -->
    <select id="gridQuick" title="å¿«é€Ÿé€‰æ‹©ï¼ˆæ–¹é˜µï¼‰">
      <option value="2">2Ã—2</option>
      <option value="3">3Ã—3</option>
      <option value="4" selected>4Ã—4</option>
      <option value="5">5Ã—5</option>
      <option value="6">6Ã—6</option>
    </select>

    <!-- è‡ªå®šä¹‰ï¼šåˆ—Ã—è¡Œï¼ˆ1..256ï¼‰ -->
    <label style="display:flex;align-items:center;gap:6px">
      è‡ªå®šä¹‰ï¼š
      <input id="cols" type="number" min="1" max="256" value="4" title="æ°´å¹³åˆ†å‰²ï¼ˆåˆ—ï¼‰" />
      Ã—
      <input id="rows" type="number" min="1" max="256" value="4" title="ç«–ç›´åˆ†å‰²ï¼ˆè¡Œï¼‰" />
      <button id="apply">åº”ç”¨</button>
    </label>

    <label style="display:flex;align-items:center;gap:6px">
      <input id="refToggle" type="checkbox" />
      å‚è€ƒå›¾
    </label>

    <div class="panel">
      <button id="shuffle" disabled>æ‰“ä¹±</button>
      <button id="reset" disabled>é‡ç½®</button>
      <button id="view" disabled>æŸ¥çœ‹å®Œæ•´å›¾</button>
      <span class="status" id="status" aria-live="polite">è¯·é€‰æ‹©ä¸€å¼ å›¾ç‰‡å¼€å§‹</span>
    </div>
  </div>

  <div class="game">
    <div id="board" class="board" aria-label="æ‹¼å›¾æ£‹ç›˜"></div>
    <div class="tray-wrap">
      <div class="tray-title">æ‹¼å›¾å—ï¼ˆæ‹–åˆ°å·¦ä¾§æ£‹ç›˜ï¼‰ï¼š</div>
      <div id="tray" class="tray" aria-label="æ‹¼å›¾ç¢ç‰‡åŒº"></div>
      <div class="note">æç¤ºï¼šæ‹–åˆ°å·²å ç”¨çš„æ ¼å­ä¼šè‡ªåŠ¨äº¤æ¢ï¼›æ‹–åˆ°å³ä¾§ç™½è‰²åŒºåŸŸå¯æ”¾å›ã€‚</div>
    </div>
  </div>

  <!-- å®Œæ•´å›¾é¢„è§ˆ -->
  <div id="overlay" class="overlay" role="dialog" aria-label="å®Œæ•´å›¾é¢„è§ˆ">
    <img id="bigImg" alt="å®Œæ•´å›¾ç‰‡é¢„è§ˆ" />
  </div>

<script>
(() => {
  'use strict';
  const fileInput = document.getElementById('file');
  const board = document.getElementById('board');
  const tray = document.getElementById('tray');
  const shuffleBtn = document.getElementById('shuffle');
  const resetBtn = document.getElementById('reset');
  const statusEl = document.getElementById('status');
  const refToggle = document.getElementById('refToggle');
  const viewBtn = document.getElementById('view');
  const overlay = document.getElementById('overlay');
  const bigImg = document.getElementById('bigImg');

  const gridQuick = document.getElementById('gridQuick');
  const inputCols = document.getElementById('cols');
  const inputRows = document.getElementById('rows');
  const applyBtn  = document.getElementById('apply');

  // ====== å‚æ•° ======
  const MASTER_SIZE = 800;          // å†…éƒ¨ç»Ÿä¸€ç¼©æ”¾åˆ°æ­£æ–¹å½¢
  let COLS = 4;                     // æ°´å¹³åˆ†å‰²æ•°ï¼ˆåˆ—ï¼‰
  let ROWS = 4;                     // ç«–ç›´åˆ†å‰²æ•°ï¼ˆè¡Œï¼‰
  let GAP_BOARD = 4;

  // ====== çŠ¶æ€ ======
  let pieces = [];                  // [{id, correct, dataURL}]
  let dragging = null;              // {el, originParent, offsetX, offsetY}
  let inPlay = false;
  let masterCanvas = null;          // ç”Ÿæˆçš„ 800Ã—800 ç”»å¸ƒ
  let masterURL = '';               // dataURL ä¾›å‚è€ƒå›¾/é¢„è§ˆ

  // ====== åˆå§‹åŒ– ======
  buildBoardCells();
  autoFitCell();
  window.addEventListener('resize', autoFitCell);

  // ====== æ–‡ä»¶åŠ è½½ä¸è£åˆ‡ ======
  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files && e.target.files[0];
    if(!file) return;
    resetGameUI(true);
    statusEl.textContent = 'æ­£åœ¨å¤„ç†å›¾ç‰‡â€¦';
    try{
      const img = await readImage(file);
      masterCanvas = cropAndScaleToSquare(img, MASTER_SIZE);
      masterURL = masterCanvas.toDataURL('image/jpeg', .92);
      setReferenceImage(masterURL);
      reSliceAndBuild();
      enableControls(true);
      inPlay = true;
      statusEl.textContent = `å·²ç”Ÿæˆ ${COLS}Ã—${ROWS} æ‹¼å›¾ï¼Œæ‹–åŠ¨å¼€å§‹æ‘†æ”¾å§ï¼`;
    }catch(err){
      console.error(err);
      statusEl.textContent = 'å¤„ç†å¤±è´¥ï¼Œè¯·æ¢ä¸€å¼ å›¾ç‰‡é‡è¯•ã€‚';
      enableControls(false);
    }
  });

  function enableControls(ok){
    shuffleBtn.disabled = !ok;
    resetBtn.disabled = !ok;
    viewBtn.disabled = !ok;
  }

  function resetGameUI(clearTrayToo){
    board.classList.remove('win-show');
    board.querySelectorAll('.piece').forEach(p=>tray.appendChild(p));
    if(clearTrayToo){ tray.innerHTML = ''; pieces = []; masterCanvas=null; masterURL=''; setReferenceImage(null); }
  }

  function readImage(file){
    return new Promise((resolve, reject)=>{
      const img = new Image();
      img.onload = ()=>resolve(img);
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }

  function cropAndScaleToSquare(img, size){
    const s = Math.min(img.naturalWidth, img.naturalHeight);
    const sx = Math.floor((img.naturalWidth - s)/2);
    const sy = Math.floor((img.naturalHeight - s)/2);
    const canvas = document.createElement('canvas');
    canvas.width = size; canvas.height = size;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(img, sx, sy, s, s, 0, 0, size, size);
    return canvas;
  }

  function sliceToPieces(canvas){
    const pw = MASTER_SIZE / COLS;   // æ¯å—å®½
    const ph = MASTER_SIZE / ROWS;   // æ¯å—é«˜
    const out = [];
    for(let r=0; r<ROWS; r++){
      for(let c=0; c<COLS; c++){
        const cv = document.createElement('canvas');
        cv.width = pw; cv.height = ph;
        cv.getContext('2d').drawImage(canvas, c*pw, r*ph, pw, ph, 0, 0, pw, ph);
        const dataURL = cv.toDataURL('image/png');
        const idx = r*COLS + c; // æ­£ç¡®ä½ç½®çº¿æ€§ä¸‹æ ‡ï¼ˆæŒ‰è¡Œï¼‰
        out.push({ id:'p'+idx, correct: idx, dataURL });
      }
    }
    return out;
  }

  function buildPieces(arr){
    tray.innerHTML = '';
    const shuffled = [...arr].sort(()=>Math.random()-0.5);
    shuffled.forEach((p, i)=>{
      const el = document.createElement('div');
      el.className = 'piece';
      el.style.backgroundImage = `url(${p.dataURL})`;
      el.dataset.correct = String(p.correct);
      el.id = p.id;
      el.setAttribute('role','img');
      el.setAttribute('aria-label', `æ‹¼å›¾å— ${i+1}/${COLS*ROWS}`);
      attachDragHandlers(el);
      tray.appendChild(el);
    });
  }

  function buildBoardCells(){
    board.innerHTML = '';
    board.style.gridTemplateColumns = `repeat(${COLS}, var(--cell))`;
    board.style.gridTemplateRows    = `repeat(${ROWS}, var(--cell))`;
    for(let i=0; i<COLS*ROWS; i++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.index = i;
      board.appendChild(cell);
    }
    const win = document.createElement('div');
    win.className = 'win';
    win.textContent = 'ğŸ‰ æ‹¼å¥½äº†ï¼';
    board.appendChild(win);
  }

  function reSliceAndBuild(){
    if(!masterCanvas) return;
    pieces = sliceToPieces(masterCanvas);
    buildBoardCells();
    autoFitCell();
    buildPieces(pieces);
  }

  // ====== è‡ªé€‚é…å•å—å°ºå¯¸ï¼ˆéšå±å¹•/åˆ—æ•°å˜åŒ–ï¼‰======
  function autoFitCell(){
    const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    const boardMax = (vw < 820) ? (vw - 32) : 480; // å·¦ä¾§æ£‹ç›˜æœ€å¤§å®½
    const pad = GAP_BOARD, gap = GAP_BOARD;
    let cell = Math.floor( (boardMax - 2*pad - (COLS-1)*gap) / COLS );
    cell = Math.max(42, Math.min(cell, 112)); // çº¦æŸèŒƒå›´
    document.documentElement.style.setProperty('--cell', cell+'px');
  }

  // ====== å‚è€ƒå›¾å¼€å…³ & å®Œæ•´å›¾æŸ¥çœ‹ ======
  function setReferenceImage(url){
    if(url) board.style.setProperty('--ref-url', `url("${url}")`);
    else board.style.removeProperty('--ref-url');
    setRefOpacity(refToggle.checked ? 0.28 : 0);
  }
  function setRefOpacity(v){ board.style.setProperty('--ref-opacity', v); }
  refToggle.addEventListener('change', ()=> setRefOpacity(refToggle.checked ? 0.28 : 0));

  viewBtn.addEventListener('click', ()=>{
    if(!masterURL) return;
    bigImg.src = masterURL;
    overlay.classList.add('show');
  });
  overlay.addEventListener('click', ()=> overlay.classList.remove('show'));

  // ====== æ‹–æ‹½ï¼ˆæŒ‡é’ˆ + è§¦æ‘¸ + å…¨å±€å…œåº•ï¼‰======
  function startDragging(el, clientX, clientY){
    if(!inPlay) return;
    const rect = el.getBoundingClientRect();
    const offsetX = clientX - rect.left;
    const offsetY = clientY - rect.top;
    dragging = { el, originParent: el.parentElement, offsetX, offsetY };
    el.classList.add('dragging');
    el.style.width = rect.width + 'px';
    el.style.height = rect.height + 'px';
    moveDraggedTo(clientX, clientY, offsetX, offsetY);
    hintDropTarget(clientX, clientY, true);
    window.addEventListener('pointermove', onPointerMove, {passive:false});
    window.addEventListener('pointerup', onPointerUp, {once:true});
  }
  function onPointerMove(e){ if(!dragging) return; e.preventDefault(); onMoveCommon(e.clientX, e.clientY); }
  function onPointerUp(e){ if(!dragging) return; onEndCommon(e.clientX, e.clientY, dragging.el); }
  function onMoveCommon(clientX, clientY){
    if(!dragging) return;
    moveDraggedTo(clientX, clientY, dragging.offsetX, dragging.offsetY);
    hintDropTarget(clientX, clientY, true);
  }
  function onEndCommon(clientX, clientY, el){
    hintDropTarget(clientX, clientY, false);
    finishDrop(clientX, clientY);
    cleanupDrag(el);
    checkWin();
    window.removeEventListener('pointermove', onPointerMove);
  }

  function attachDragHandlers(el){
    // Pointer Events
    el.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      el.setPointerCapture?.(e.pointerId);
      startDragging(el, e.clientX, e.clientY);
    });
    // è§¦æ‘¸å…œåº•
    el.addEventListener('touchstart', (e)=>{
      if(!e.touches || !e.touches[0]) return;
      e.preventDefault();
      const t = e.touches[0];
      startDragging(el, t.clientX, t.clientY);
      const touchMove = (ev)=>{
        if(!dragging) return;
        const tt = ev.touches[0];
        if(!tt) return;
        ev.preventDefault();
        onMoveCommon(tt.clientX, tt.clientY);
      };
      const touchEnd = (ev)=>{
        const tt = (ev.changedTouches && ev.changedTouches[0]) || {clientX:-999, clientY:-999};
        onEndCommon(tt.clientX, tt.clientY, el);
        window.removeEventListener('touchmove', touchMove);
        window.removeEventListener('touchend', touchEnd);
        window.removeEventListener('touchcancel', touchCancel);
      };
      const touchCancel = ()=>{
        if(dragging){
          (dragging.originParent || tray).appendChild(el);
          cleanupDrag(el);
          hintDropTarget(-999,-999,false);
        }
        window.removeEventListener('touchmove', touchMove);
        window.removeEventListener('touchend', touchEnd);
        window.removeEventListener('touchcancel', touchCancel);
      };
      window.addEventListener('touchmove', touchMove, {passive:false});
      window.addEventListener('touchend', touchEnd, {once:true});
      window.addEventListener('touchcancel', touchCancel, {once:true});
    }, {passive:false});
  }

  function moveDraggedTo(clientX, clientY, ox, oy){
    const x = clientX - ox;
    const y = clientY - oy + window.scrollY;
    const el = dragging.el;
    el.style.left = x + 'px';
    el.style.top  = y + 'px';
    if(el.parentElement !== document.body){
      document.body.appendChild(el);
    }
  }

  function getDropTarget(clientX, clientY){
    const el = document.elementFromPoint(clientX, clientY);
    if(!el) return null;
    return el.closest('.cell, #tray');
  }

  function finishDrop(clientX, clientY){
    const target = getDropTarget(clientX, clientY);
    const piece = dragging.el;
    const from = dragging.originParent;

    if(target && (target.classList.contains('cell') || target.id === 'tray')){
      if(target.id === 'tray'){
        tray.appendChild(piece);
      }else{
        const occupied = target.querySelector('.piece');
        if(occupied){
          if(from && from.classList && from.classList.contains('cell')) from.appendChild(occupied);
          else tray.appendChild(occupied);
        }
        target.appendChild(piece);
      }
      statusEl.textContent = 'æ‹–æ”¾æˆåŠŸ âœ…';
    }else{
      tray.appendChild(piece); // å…œåº•å›æ”¶ï¼Œé¿å…æ®‹ç•™
      statusEl.textContent = 'æœªæ”¾åœ¨æœ‰æ•ˆåŒºåŸŸï¼Œå·²å›æ”¶åˆ°æ‰˜ç›˜';
    }
  }

  function cleanupDrag(el){
    if(el.parentElement === document.body){
      (dragging?.originParent || tray).appendChild(el);
    }
    el.classList.remove('dragging');
    el.style.left = el.style.top = el.style.width = el.style.height = '';
    dragging = null;
  }

  function hintDropTarget(clientX, clientY, on){
    document.querySelectorAll('.drop-hint').forEach(n=>n.classList.remove('drop-hint'));
    if(!on) return;
    const tgt = getDropTarget(clientX, clientY);
    if(tgt) tgt.classList.add('drop-hint');
  }

  // ====== èƒœåˆ©æ£€æŸ¥ ======
  function checkWin(){
    const cells = board.querySelectorAll('.cell');
    for(let i=0;i<cells.length;i++){
      const p = cells[i].querySelector('.piece');
      if(!p){ board.classList.remove('win-show'); return false; }
      if(Number(p.dataset.correct) !== i){ board.classList.remove('win-show'); return false; }
    }
    board.classList.add('win-show');
    statusEl.innerHTML = 'æ­å–œå®Œæˆï¼ğŸ‰ <a href="#" id="seeFull">æŸ¥çœ‹å®Œæ•´å›¾</a>';
    const link = document.getElementById('seeFull');
    if(link){ link.addEventListener('click', (e)=>{ e.preventDefault(); viewBtn.click(); }, {once:true}); }
    return true;
  }

  // ====== æ§ä»¶ ======
  shuffleBtn.addEventListener('click', ()=>{
    if(!pieces.length) return;
    board.querySelectorAll('.piece').forEach(p=>tray.appendChild(p));
    const arr = Array.from(tray.querySelectorAll('.piece'));
    arr.sort(()=>Math.random()-0.5).forEach(p=>tray.appendChild(p));
    board.classList.remove('win-show');
    statusEl.textContent = 'å·²æ‰“ä¹±ï¼Œè¯·ç»§ç»­~';
  });

  resetBtn.addEventListener('click', ()=>{
    if(!pieces.length) return;
    board.querySelectorAll('.piece').forEach(p=>tray.appendChild(p));
    board.classList.remove('win-show');
    statusEl.textContent = 'å·²é‡ç½®åˆ°æ‰˜ç›˜ã€‚';
  });

  // å¿«é€‰ï¼ˆæ–¹é˜µï¼‰
  gridQuick.addEventListener('change', ()=>{
    const n = parseInt(gridQuick.value,10);
    setGrid(n, n, false);
  });

  // è‡ªå®šä¹‰åº”ç”¨
  applyBtn.addEventListener('click', ()=>{
    let c = clampInt(inputCols.value, 1, 256);
    let r = clampInt(inputRows.value, 1, 256);
    inputCols.value = c; inputRows.value = r; // å›å†™æ ¡æ­£å€¼
    setGrid(c, r, true);
  });

  function clampInt(v, min, max){
    v = parseInt(v, 10);
    if(isNaN(v)) v = min;
    return Math.max(min, Math.min(max, v));
  }

  function setGrid(c, r, fromCustom){
    COLS = c; ROWS = r;
    // åŒæ­¥å¿«é€‰ï¼šå¦‚æœæ˜¯è‡ªå®šä¹‰æˆ–éæ–¹é˜µï¼Œåˆ™æŠŠå¿«é€‰ç½®ç©ºï¼ˆä¸æ”¹å˜ç”¨æˆ·è¾“å…¥ï¼‰
    if(fromCustom || COLS !== ROWS){
      gridQuick.selectedIndex = -1;
    }else{
      // æ‰¾åˆ°å¯¹åº”é¡¹ï¼Œå¦åˆ™æ¸…ç©º
      const opt = Array.from(gridQuick.options).find(o => parseInt(o.value,10) === COLS);
      if(opt) gridQuick.value = String(COLS); else gridQuick.selectedIndex = -1;
    }
    buildBoardCells();
    autoFitCell();
    if(masterCanvas){
      reSliceAndBuild();
      statusEl.textContent = `å·²åˆ‡æ¢åˆ° ${COLS}Ã—${ROWS}ï¼Œå¹¶é‡æ–°æ‰“ä¹±ã€‚`;
    }else{
      statusEl.textContent = `å·²åˆ‡æ¢åˆ° ${COLS}Ã—${ROWS}ã€‚è¯·å…ˆé€‰æ‹©å›¾ç‰‡ã€‚`;
    }
  }

})();
</script>
</body>
</html>